/* jshint wsh:true */ // Indica que este código deve ser executado em um ambiente Windows Script Host (WSH)

/*
 * readlineSync
 * https://github.com/anseki/readline-sync
 *
 * Copyright (c) 2019 anseki
 * Licensed under the MIT license.
 */

// Define constantes para modos de leitura/escrita e mensagem de erro
var
  FSO_ForReading = 1, // Modo de leitura para FileSystemObject
  FSO_ForWriting = 2, // Modo de escrita para FileSystemObject
  PS_MSG = 'Microsoft Windows PowerShell is required.' +
    ' https://technet.microsoft.com/en-us/library/hh847837.aspx', // Mensagem de erro caso PowerShell não esteja disponível

  input = '', // Inicializa a variável de entrada
  fso, // Declaração da variável para FileSystemObject
  tty, // Declaração da variável para terminal
  options = (function(conf) { // Função anônima que processa opções de configuração
    var options = {}, // Objeto para armazenar opções
      arg, // Variável temporária para argumentos
      args = // Captura os argumentos passados para o script
      (function() {
        var args = [], i, iLen;
        for (i = 0, iLen = WScript.Arguments.length; i < iLen; i++)
          { args.push(WScript.Arguments(i)); } // Armazena cada argumento em um array
        return args; // Retorna o array de argumentos
      })(),
      confLc = {}, // Objeto para armazenar a configuração em minúsculas
      key; // Variável para iterar chaves

    // Função que decodifica argumentos que contêm códigos de caracteres
    function decodeArg(arg) {
      return arg.replace(/#(\d+);/g, function(str, charCode) {
        return String.fromCharCode(+charCode); // Substitui o código pelo caractere correspondente
      });
    }

    // Converte a configuração para minúsculas e armazena
    for (key in conf) {
      if (conf.hasOwnProperty(key))
        { confLc[key.toLowerCase()] = {key: key, type: conf[key]}; }
    }

    // Processa os argumentos fornecidos pelo usuário
    while (typeof(arg = args.shift()) === 'string') {
      if (!(arg = (arg.match(/^\-+(.+)$/) || [])[1])) { continue; } // Extrai o nome do argumento
      arg = arg.toLowerCase(); // Converte para minúsculas
      if (confLc[arg]) {
        options[confLc[arg].key] =
          confLc[arg].type === 'boolean' ? true : // Define como verdadeiro se for booleano
          confLc[arg].type === 'string' ? args.shift() : null; // Armazena o valor da string ou nulo
      }
    }

    // Garante que as opções de string sejam decodificadas corretamente
    for (key in conf) {
      if (conf.hasOwnProperty(key) && conf[key] === 'string') {
        if (typeof options[key] !== 'string') { options[key] = ''; }
        else { options[key] = decodeArg(options[key]); }
      }
    }
    return options; // Retorna o objeto de opções
  })({
    display:        'string', // Opção para exibir texto
    displayOnly:    'boolean', // Opção para exibição somente
    keyIn:          'boolean', // Opção para entrada de chave
    hideEchoBack:   'boolean', // Opção para ocultar a entrada do usuário
    mask:           'string' // Opção para máscara de entrada
  });

// Verifica as opções e decide como ler a entrada do usuário
if (!options.hideEchoBack && !options.keyIn) {
  if (options.display) { writeTTY(options.display); } // Escreve no terminal se a opção display estiver definida
  if (!options.displayOnly) { input = readByFSO(); } // Lê a entrada do usuário
} else if (options.hideEchoBack && !options.keyIn && !options.mask) {
  if (options.display) { writeTTY(options.display); }
  if (!options.displayOnly) { input = readByPW(); } // Lê a entrada oculta
} else {
  // Mensagem de erro se as opções não forem válidas
  WScript.StdErr.WriteLine(PS_MSG);
  WScript.Quit(1); // Encerra o script com erro
}

// Escreve a entrada no stdout, encapsulada em aspas
WScript.StdOut.Write('\'' + input + '\'');

// Encerra o script
WScript.Quit();

// Função para escrever texto no terminal
function writeTTY(text) {
  try {
    tty = tty || getFso().OpenTextFile('CONOUT$', FSO_ForWriting, true); // Abre o terminal para escrita
    tty.Write(text); // Escreve o texto no terminal
  } catch (e) {
    // Mensagem de erro se houver falha na escrita
    WScript.StdErr.WriteLine('TTY Write Error: ' + e.number +
      '\n' + e.description + '\n' + PS_MSG);
    WScript.Quit(e.number || 1); // Encerra o script com erro
  }
}

// Função para ler a entrada do usuário usando FileSystemObject
function readByFSO() {
  var text;
  try {
    text = getFso().OpenTextFile('CONIN$', FSO_ForReading).ReadLine(); // Lê uma linha do terminal
  } catch (e) {
    // Mensagem de erro se houver falha na leitura
    WScript.StdErr.WriteLine('TTY Read Error: ' + e.number +
      '\n' + e.description + '\n' + PS_MSG);
    WScript.Quit(e.number || 1); // Encerra o script com erro
  }
  return text; // Retorna o texto lido
}

// Função para ler a entrada oculta (como senhas) usando ScriptPW
function readByPW() {
  var text;
  try {
    text = WScript.CreateObject('ScriptPW.Password').GetPassword() // Obtém a senha usando ScriptPW
      // Corrige um possível bug que retorna dados ilegais
      .replace(/[\u4000-\u40FF]/g, function(chr) {
        var charCode = chr.charCodeAt(0);
        return charCode >= 0x4020 && charCode <= 0x407F ?
          String.fromCharCode(charCode - 0x4000) : '';
      });
  } catch (e) {
    // Mensagem de erro se houver falha ao obter a senha
    WScript.StdErr.WriteLine('ScriptPW.Password Error: ' + e.number +
      '\n' + e.description + '\n' + PS_MSG);
    WScript.Quit(e.number || 1); // Encerra o script com erro
  }
  writeTTY('\n'); // Escreve uma nova linha no terminal
  return text; // Retorna o texto lido
}

// Função para obter uma instância de FileSystemObject
function getFso() {
  if (!fso) { fso = new ActiveXObject('Scripting.FileSystemObject'); } // Cria um novo objeto se não existir
  return fso; // Retorna o objeto FileSystemObject
}
